#!/usr/bin/env python
import appdirs
import copy
import os
import json
import re
import sys
import time

DELTA_JSON = {
    'core': {
        'binds': {
            '/run/udev': {
                'bind': '/run/udev',
                'mode': 'ro'
            },
            '/etc/machine-id': {
                'bind': '/etc/machine-id',
                'mode': 'ro'
            },
            '/etc/dhcpcd.conf': {
                'bind': '/etc/dhcpcd.conf',
                'mode': 'rw'
            },
            "/usr/blueos/userdata": {
                "bind": "/usr/blueos/userdata",
                "mode": "rw"
            }
        }
    }
}

import collections
from commonwealth.utils.commands import run_command

# Copyright 2016-2022 Paul Durivage
# Licensed under the Apache License, Version 2.0 (the "License");
# Based on: https://gist.github.com/angstwad/bf22d1822c38a92ec0a9
def dict_merge(dct, merge_dct):
    for k, v in merge_dct.items():
        if (k in dct and isinstance(dct[k], dict) and isinstance(merge_dct[k], dict)):  #noqa
            dict_merge(dct[k], merge_dct[k])
        else:
            dct[k] = merge_dct[k]

def update_startup() -> bool:
    startup_path = os.path.join(appdirs.user_config_dir('bootstrap'), 'startup.json')
    config = {}
    with open(startup_path, mode="r", encoding="utf-8") as startup_file:
        config = json.load(startup_file)
        old_config = copy.deepcopy(config)
        dict_merge(config, DELTA_JSON)
        if old_config == config:
            # Don't need to apply or restart if the content is the same
            return False

    with open(startup_path, mode="w", encoding="utf-8") as startup_file:
        result = json.dumps(config, indent=4, sort_keys=True)
        startup_file.write(result)

        # Patch applied and system needs to be restarted for it to take effect
        return True

def update_cgroups() -> None:
    print("Running cgroup update..")
    # add cgroups options to cmdline if they are not there already,
    command = '''sudo sh -c '\
    grep -q cgroup /boot/cmdline.txt || (\
        truncate --size -1 /boot/cmdline.txt;\
        echo " cgroup_enable=cpuset cgroup_memory=1 cgroup_enable=memory" >> /boot/cmdline.txt;\
    )' '''
    print(run_command(command, False))


def update_dwc2() -> bool:
    print("Running dwc2 update..")

    # Retrieve the config file
    config_file = '/boot/config.txt'
    config_content = load_file(config_file).splitlines()
    unpatched_config_content = config_content.copy()

    # Add dwc2 overlay in pi4 section if it doesn't exist
    dwc2_overlay_config = 'dtoverlay=dwc2,dr_mode=otg'
    pi4_session_name = 'pi4'
    boot_config_add_configuration_at_session(config_content, dwc2_overlay_config, pi4_session_name)

    # Remove any unprotected and conflicting dwc2 overlay configuration
    dwc2_overlay_match_pattern = '^[#]*dtoverlay=dwc2.*$'
    config_content = boot_config_filter_conflicting_configuration_at_session(config_content, dwc2_overlay_match_pattern, dwc2_overlay_config, pi4_session_name)

    # Save if needed, with backup
    backup_identifier = 'before_update_dwc2'
    if unpatched_config_content != config_content:
        config_content_str = '\n'.join(config_content)
        save_file(config_file, config_content_str, backup_identifier)

    # Retrieve the cmdline file
    cmdline_file = '/boot/cmdline.txt'
    cmdline_content = load_file(cmdline_file).replace('\n','').split(' ')
    unpatched_cmdline_content = cmdline_content.copy()

    # Add the dwc2 module configuration to enable USB OTG as ethernet adapter
    boot_cmdfile_add_modules(cmdline_content, 'modules-load', ['dwc2', 'g_ether'])

    # Don't need to apply if the content is the same, restart if the above part requires
    if unpatched_cmdline_content == cmdline_content:
        return unpatched_config_content != config_content

    # Make a backup file before modifying the original one
    cmdline_content_str = ' '.join(cmdline_content)
    save_file(cmdline_file, cmdline_content_str, backup_identifier)

    # Patch applied and system needs to be restarted for it to take effect
    return True


    command = '''sudo sh -c '\
    grep -q "dtoverlay=dwc2" /boot/config.txt || (
        echo "dtoverlay=dwc2" | sudo tee -a /boot/config.txt
    )' '''
    print(run_command(command, False))

def ensure_nginx_permissions() -> bool:
    # ensure nginx can read the userdata directory
    command = "sudo chown -R www-data:www-data /usr/blueos/userdata"
    print(run_command(command, False))

    # This patch doesn't require restart to take effect
    return False

def ensure_user_data_structure_is_in_place() -> bool:
    # ensures we have all base folders in userdata
    commands = [
        "sudo mkdir -p /usr/blueos/userdata/images/vehicle",
        "sudo mkdir -p /usr/blueos/userdata/images/logo",
        "sudo mkdir -p /usr/blueos/userdata/styles",
    ]
    for command in commands:
        print(run_command(command, False))

    # This patch doesn't require restart to take effect
    return False

def main() -> int:

    current_git_version = os.getenv('GIT_DESCRIBE_TAGS')
    match = re.match(r'(?P<tag>.*)-(?P<commit_number>\d+)-(?P<commit_hash>[a-z0-9]+)', current_git_version)
    tag, commit_number, commit_hash = match['tag'], match['commit_number'], match['commit_hash']
    print(f"Running BlueOS: {tag=}, {commit_number=}, {commit_hash=}")

    # TODO: parse tag as semver and check before applying patches
    patches_to_apply = [
        update_startup,
        update_cgroups,
        update_dwc2,
        ensure_user_data_structure_is_in_place,
        ensure_nginx_permissions,
    ]

    print("The following patches will be applied if needed:", [patch_to_apply.__name__ for patch_to_apply in patches_to_apply])

    patches_requiring_restart = [patch.__name__ for patch in patches_to_apply if patch()]
    if patches_requiring_restart:
        print("The system will restart in 10 seconds because the following applied patches required restart:", patches_requiring_restart)
        time.sleep(10)
        sys.exit(1)

    return 0

if __name__ == "__main__":
    main()
